JS Код, написанный C#-разработчиком (ровно как и C++, Java) обычно выглядит не очень. Чтобы нормально писать на JS, надо основательно этим заниматься, а не наскоками-набегами. TypeScript как раз предоставляет мостик из мира C# в мир JS. Этот мостик позволяет писать код, похожий на нормальный, привычный ООП в C#, затем компилировать его в JS. НО от знания и понимания JS кода, TypeScript не освобождает, он лишь помогает человеку из не JS мира писать структурированный код в привычном стиле. 

Лично мой код на JS, несмотря на то, что я старался использовать опыт/мозг/google все равно похож на макароны. А чем дальше идет разработка <a href="http://habrahabr.ru/post/215097/">системы</a>, тем больше хочется накрутить именно интерфейсных функций. После попытки добавить парочку таких функций, код стал еще менее понимаемым. Typescript и был создан, чтобы дать возможность .net разработчикам писать код, в более привычном стиле.

<habracut text="Я себе поставил задачу: сделать код более понимаемым и расширяемым для тех, кто в JS не гуру." />
<h6>Моя интерпретация терминов понимаемый-расширяемый</h6>
<ul>
	<li>надо написать более-менее объектно-ориентированный код. Нужно, чтобы был объект контекста страницы, чтобы каждая диаграмма была объектом, содержащим все свои внутренности (chart, коллекцию точек, возможность открыть и закрывать каждый чарт отдельно, разрешить удалять последние точки с графика/или собирать точки бесконечно долго); </li>
	<li>Хотелось получить контроль над типами, т.к. очень неприятно разбираться в runtime, почему в объекте нет свойства, которое мне нужно (можно перечислить все стандартные проблемы отсутствия строгой типизации).</li>
</ul>
<h5>Пути решения поставленной задачи</h5>
Можно было пойти длинным/правильным путем и изучить, как в JS пишется ООП код (на JS я немного писал, так что совсем уж нубом себя не считаю). 

Однако, я решил пойти более коротким (как я считал) путем, хотя истинные JS-guys меня, наверно, заклюют, что «кодогенерация отстой, надо писать нормальный код, самому; вложите свои силы, и будет вам вечная польза». Я согласен с этими высказываниями, но  посчитал, что на TypeScript напишу и разберусь быстрее.

Большая часть ошибок, с которыми я сталкивался во время отладки приложения, - это javascript ошибки. Соответственно  гуглить ответы надо было именно для JS, а не для TypeScript. По этому, знание JS ни кто не отменял!

<h5>Код до переписывания</h5>
Во время написания кода на js были постоянные проблемы из серии «отсутствие контроля типов». Например, в runtime получаешь ошибку, что у объекта нет такого свойства, и после разбирательства ты понимаешь, что тебе нужен вложенный объект (или наоборот родительский). А еще хуже - описки в именах или большие-малые буквы.

В итоговом коде получились: вложенные цепочки вызовов, глобальные переменные. На каждое действие производится работа с глобальными переменными, никаких тебе объектов.
<spoiler title="Вот так, код выглядел до переписывания.">Красным выделена работа с глобальными объектами.
Кода не много - ~156 стро. Я понимал, что на TypeScript кода будет больше, да и TypeScript сгенерирует сильно больше JavaScript кода, чем сейчас есть, и это было понятно с самого начала.
<img src="http://habrastorage.org/getpro/habr/post_images/010/dc1/9c8/010dc19c8f3a37185c9cc1e631d51f42.jpg"/>
<img src="http://habrastorage.org/getpro/habr/post_images/0e6/850/e55/0e6850e55fa21c47a3edeb36e923dbc1.jpg"/></spoiler>

<h6>Комплект используемых JS библиотек</h6>
<ul>
	<li>Jquery - вызов webservice, dom;</li>
	<li>Jquery.SignalR - работа с SignalR;</li>
	<li>CanvasJS - отрисовка графики.</li>
</ul>
Ко всем библиотекам, кроме CanvasJS, есть TypeScript заголовки, которые пришлось написать самому. Это несложно, если понимаешь, как их писать.

<h4>Реализация</h4>
Первое, что надо было сделать - это написать на TypeScript объектную модель сообщений. То, что выходит с сервера должно быть 1х1 отображено в TypeScript и писать код, с контролем типов.

<spoiler title="В итоге это выглядело так:"><img src="http://habrastorage.org/getpro/habr/post_images/000/aba/9a8/000aba9a8367be9da014fb5c8fa47a8e.jpg"/>
<img src="http://habrastorage.org/getpro/habr/post_images/f88/758/b55/f88758b55f1636b51dad4cc23d1e388d.jpg"/></spoiler>

TypeScript позволяет полностью (1х1) сделать модели, т.к. поддерживает Enum, Class, Namespace (module), Interface, Generics. 

Несколько примеров:
<spoiler title="Enums"><img src="http://habrastorage.org/getpro/habr/post_images/d28/d5a/9fa/d28d5a9fac4b50be9dddbed459a263d0.jpg"/></spoiler>
<spoiler title="Наследование и Generics"><img src="http://habrastorage.org/getpro/habr/post_images/1be/f88/450/1bef88450648c4097db692b33194fa99.jpg"/></spoiler>

Объём кода на TypeScript только для моделей данных получился в 209 строк (если убрать пропуски строк и скобки, будет 60строк). JS кода было сгенерировано еще больше: 259 строк (пробелов не было, но были закрывающие скобки).

<h4>Реализация объектной модели страницы</h4>
<spoiler title="Страница представляла из себя объект, который содержит коллекцию диаграмм + proxy до SignalR. ">
<img src="http://habrastorage.org/getpro/habr/post_images/55e/8fb/219/55e8fb219642683487d415ad6b1f7683.jpg"/>
</spoiler>
Далее дергаем метод init, в котором производим все операции инициализации: подключение к SignalR hub, получение данных с API, а также подписываемся на событие diagramHubNotify.

<spoiler title="А вот каждая диаграмма уже отдельно содержит в себе все свои данные: chart + коллекцию точек.">
<img src="http://habrastorage.org/getpro/habr/post_images/1c4/b57/e52/1c4b57e526bbee4f4adebb29c4d51e02.jpg"/>
</spoiler>
<spoiler title="Код инициализации chart абсолютно идентичен JS коду."><img src="http://habrastorage.org/getpro/habr/post_images/0d4/a59/b4a/0d4a59b4a0fc6ff26d3e399036fac069.jpg"/></spoiler>
<spoiler title="Обработчик на добавление новой точки в chart">
<img src="http://habrastorage.org/getpro/habr/post_images/32b/0ca/186/32b0ca18636bd17679755ea503c005e3.jpg"/>
</spoiler>
<spoiler title="Класс самой line на chart">
<img src="http://habrastorage.org/getpro/habr/post_images/4e5/0b3/562/4e50b3562b2e7538503a4e628ca301ba.jpg"/>
</spoiler>
<spoiler title="Точка">
<img src="http://habrastorage.org/getpro/habr/post_images/7a2/304/d97/7a2304d976806d10aaa4ac2fa9d20ffe.jpg"/>
</spoiler>

<h5>Тонкости написания кода на typescript</h5>
<h6>Проблема SignalR + TypeScript и ее решение.</h6>
JQuery.SignalR написан на javascript, это framework, позволяющий работать с SignalR, не залезая в тонкости реализации работы с websockets, или другими транспортами.
После старта SignalRHub генерируется proxy на JS для более приятной работы с SignalR со стороны JS - это великолепно.
<spoiler title="Выглядит это так"><img src="http://habrastorage.org/getpro/habr/post_images/2b0/d3a/c03/2b0d3ac032b4345970c4baaf3a4dacfb.jpg"/></spoiler>
Можно работать и без этой proxy, но тогда наш код будет немного менее строго типизирован, и придется брать объект по имени, а не свойство объекта.

Я хочу использовать этот сгенерированный JS proxy, но вот незадача: каждый раз он генерируется заново и не генерирует никаких TypeScript артефактов - просто голый JS код. Таким образом, получается, что proxy есть, а использовать ее в строго типизированном TypeScript коде невозможно без дополнительных трудозатрат. <a href="http://nickberardi.com/SignalR-and-TypeScript/">Здесь </a>человек описывает как это обойти.
Я смог понять, как это работает только со второго подхода, поэтому сначала написал работу без proxy, а потом просто переписал.
<spoiler title="Мой вариант *.d.ts файла.">
<img src="http://habrastorage.org/getpro/habr/post_images/c0b/e9c/823/c0be9c823c3fa8f3e5ea6ed153459f8b.jpg"/></spoiler>
<spoiler title="И соответствующий ему SignalR hub с 2 серверными методами и 1 клиентским."> 
<img src="http://habrastorage.org/getpro/habr/post_images/611/09b/51a/61109b51a37b9a513ab7209938a3ab8c.jpg"/>
</spoiler>

<h5>TypeDefinition для CanvasJS</h5>
Как я уже говорил ранее, для CanvasJS нет ни каких typedefinition файлов. Значит, придется самому сесть, разобраться и написать его.
Давайте взглянем на внутренности *d.ts файла от jquery, чтобы понять, как нам писать самим. В интернете очень плохо с описанием, как это делать.
<spoiler title="Открываем d.ts файл от jquery."><img src="http://habrastorage.org/getpro/habr/post_images/8b9/993/8a3/8b99938a324605d528e28b856e65fc3a.jpg"/></spoiler>
 Что мы видим: 
Мы видим огромный файл с интерфейсами, по которому не генерируется JS. Фактически этот файл нужен, чтобы “Make the compiler happy”. Компилятор видит интерфейсы, описывающие классы и методы, и генерирует вызовы JS версии jquery на основе этих интерфейсов. На развернутом сайте никаких упоминаний о d.ts файлах нет. На деле - это сродни C++ .h файлам, а на целевой системе нужно надеяться, что будут реализации этих описанных классов. В нашем случае будет загружена jquery библиотека.

<h6>Пишем CanvasJS d.ts</h6>
Я из всего CanvasJS использую только 2 вещи:
<ul>
	<li>Конструктор класса chart;</li>
	<li>Метод render класса chart. </li>
</ul>
<spoiler title="Отлично: наша жизнь оказывается не такой уж и сложной."><img src="http://habrastorage.org/getpro/habr/post_images/082/ae8/4c2/082ae84c2189edfb11e02929a92edcb2.jpg"/></spoiler>
Мы создаем интерфейс Chart, в котором должен быть конструктор и метод.
Дальше - немного черной магии, чтобы этот интерфейс использовать.
Создаем интерфейс CanvasJSStatic. Его единственная задача - хранить объект chart. Именно этот интерфейс мы теперь высовываем наружу из нашего  d.ts файла в качестве переменной CanvasJS типа CanvasJSStatic. Это все нужно, чтобы компилятор TypeScript подставил в результирующий JS код строчку «new CanvasJS.Chart()»
Если возникнут вопросы по этому кусочку кода, советую лично прочитать про d.ts файлы (про это можно отдельную статью написать, но моя цель не в этом).
<spoiler title="Стартовая точка приложения">
<img src="http://habrastorage.org/getpro/habr/post_images/6e1/752/867/6e1752867df1220ea009d9b2be3125e8.jpg"/>
</spoiler>

<h4>Итог:</h4>
Мы полностью написали весь интерфейс на TypeScript и 3 строчки на JS.
<spoiler title="И все работает"><img src="http://habrastorage.org/getpro/habr/post_images/7b9/8d9/c4b/7b98d9c4b1ca76fe01a8337d42cb17ef.jpg"/></spoiler>
У меня получилось 279 строк логики на TypeScript + 259 строк описания классов входных данных от API+hub.
Итого: ~500 строк на TypeScript. На JS кода получилось больше, но зато мы получили возможность писать объектно-ориентированный код.

Затраченное время:-1.5 дня я потратил на написание этого кода. Плюс еще день писал статью.
Мой уровень JS/TypeScript до написания проекта был не велик. По TypeScript я смотрел <a href="http://pluralsight.com/training/Courses/TableOfContents/typescript">курс </a>, а опыта не было вообще. По JS я смотрел много разных курсов, но из практического опыта на js я писал совсем чуть-чуть (poi на яндекс карте рисовал)

<h5>Наставление от прошедшего по минам тем, кто по ним только пойдет…</h5>
Ниже я опишу несколько проблем, которые мой мозг поначалу отказывался понимать, и методы их решения. На самом деле, это даже не проблемы, а, скорее, просто недопонимание.

<h6>Проблема Compilation time vs RunTime</h6>
Все разработчики знакомы с проблемой «у меня работает, а на сервере не работает» и с её разновидностью «у меня компилится, а где-то еще не компилится» (build server/другие разработчики). В TypeScript есть похожая проблема. 
В первых строчках кода, ты подключаешь другой файл.  Код компилируется, а в RunTime ты видишь совершенно невнятную ошибку: ”Uncaught TypeError: undefined is not a function” 
<spoiler title="на тривиальной строке:"><img src="http://habrastorage.org/getpro/habr/post_images/2a8/aad/3b0/2a8aad3b0fb33bb2be8721f303f15816.jpg"/></spoiler>
Как человеку, который не очень силен в JS, мне она поначалу мало что сказала: очевидно, что класс почему-то не виден в RunTime. Начал гуглить и нашел <a href="http://javascript.ru/forum/css-html/25833-uncaught-typeerror-undefined-not-function.html">первую подсказку
</a>
"Незаданная переменная - это вам не функция!"
Означает это, что скобочки "()" приставлены к тому, чего нет.
Она мне пока не выдала решение, но я понял куда надо копать. На всякий случай решил посмотреть <a href="http://pluralsight.com/training/Courses/TableOfContents/TypeScript">видео по TypeScript </a>на тему module.- тут автор произнес шикарную фразу, смысл которой был таков: надо проверять, в каком порядке загружены наши JS файлы на html страницу из-за потенциальных зависимостей.

И тут меня осенило, что решение-то тривиальное. Я заглянул в свой index.html и обнаружил, что подключил всего 1 JS файл, а второй - нет. Первая мысль была: «Я идиот»! Включил второй файл, и полетело. 
После этого я понял… Есть compile time у файлов TypeScript, а есть runtime у javascript. В Compile Time в .ts файле подключены все нужные зависимости и все компилируется, а в runtime этих зависимостей не было. 
Пример далекий от JS. Во время компиляции на вашей машине была нужная библиотека (на пример в gac или просто под ногами). Затем вы запустили программу на другой машине, словили runtime exception, потому что на этой машине нет этой библиотеки. Ваш браузер и ваш текстовый редактор - это абсолютно разные системы, как машина на которой код компилировался и та, где он запускался.

<h6>This или не this</h6>
В общем, пока пишешь простой линейный код, без каких-либо promises (для любителей .net – это аналог task.continuewith они же continuation), - все ок. Проблема возникает, как только появляется асинхронность. Хождение к веб сервису, например.
Код отлично компилируется, работает intellisence и типы выводятся корректно. Проблема начинается в runtime.
У меня 2 вызова одной и той же функции: на первичное получение данных от API controller и на последующее, когда из SignalR hub прилетают обновления. В первом случае все отлично работает. Во втором - нет. Валится ошибка при попытке получить любой объект из контекста страницы. Логика подсказывает, что мы не в объекте страницы. Открываем отладчик (этот пример пусть будет в chrome)

<spoiler title="Нормальный пример:">
<img src="http://habrastorage.org/getpro/habr/post_images/cec/7ca/55a/cec7ca55abdfd21e3a88cafb5b296350.jpg"/>
</spoiler>
<spoiler title="Не работающий пример:">
<img src="http://habrastorage.org/getpro/habr/post_images/217/937/1c1/2179371c167a7f95498da40b416a6049.jpg"/></spoiler>
Если присмотреться, то они отличаются. Отличаются тем, что в замыкании хранятся совершенно разные объекты. В первом случае - это класс-контекст страницы, во втором - SignalRproxy. TypeScript во время разработки ничего плохого не сказал. Вызов, по мнению компилятора, был совершенно корректен. А вот в runtime у нас не тот объект.

<spoiler title="Код до решения ошибки:">
<img src="http://habrastorage.org/getpro/habr/post_images/a9f/796/5bf/a9f7965bf63113b6d7255b0cb248538b.jpg"/>
</spoiler>

Если посмотреть внимательно, станет видно, что я подписываю на событие this.onUpdateRecive, а на самом деле надо было создать другую функцию, которая вызывает onUpdateRecieve, и тогда все будет хорошо. В замыкание в качестве this попадает правильный контекст переменной. Проблема тривиальная, но контроль типов нас не спас, и выстрелить себе в ногу можно как и в js.
<spoiler title="Код до решения после:">
<img src="http://habrastorage.org/getpro/habr/post_images/974/494/c90/974494c9039ea20ccd893e1dafd3397a.jpg"/>
</spoiler> 
Особенно внимательные заметят, что ниже есть получение через jquery списка диаграмм из  API controller, и он написан уже правильно. Если написать его в том стиле this.onGetDiagrams вместо (data)=>{this.onGetDiagram}, то мы получим ту же самую проблему, но уже при вызове JQuery.

<h6>Проблемы с контролем, типом или Type Any</h6>
Чистый TypeScript код в реальном приложении вряд ли может быть. Для того, чтобы связать TypeScript код с JS кодом, нужны type definitions файлы, в которых будут описаны интерфейсы JS кода. TypeDefinitions *.t.ds файлы чем-то похожи по своей сути на  *.h файлы в C/C++). Дело в том, что как только мы выходим в не строго типизированный мир, нас ждут все его радости.
<spoiler title="Вот пример t.ds файла от SignalR"><img src="http://habrastorage.org/getpro/habr/post_images/80d/599/e2e/80d599e2e7d153c1b051d37785589223.jpg"/></spoiler>
Если к нему присмотреться, то мы увидим кучу методов, которые принимают any[], т.е. что угодно. И здесь, в отличие от C#, нам никто на этапе компиляции не даст по рукам, если мы подставим странный тип на вход. C# предупредит, если мы попытаемся подписать на делегат метод с не верной сигнатурой. А здесь - пожалуйста, ибо сигнатура фактически отсутствует.
В общем, как только мы выходим за границу TypeScript, мы вступаем в JS мир, а там уже действуют JS законы.

ссылка на <a href="https://github.com/SychevIgor/blog/master/Realtimemonitoring/TypeScript">github</a>