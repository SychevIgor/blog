Итак: ВСЕ любят OpenSource. Ну, или, по крайней мере, 99% говорят и считают, что OpenSource - это хорошо. Я тоже так считаю. На OpenSource библиотеках очень хорошо учиться. Обычно OpenSource это большие проекты (для студента, все, что больше 3-4 тысяч строк уже серьезная вещь), которые писали разные люди, в разное время. Можно посмотреть стиль кода, стили написания, организацию, нотации именования переменных. Можно посмотреть, чем вообще занимаются люди вокруг - ведь с тобой в университете учится очень мало специалистов, интересы с которыми у тебя одни сходятся. Например: Я программирую на 3 языках, а сосед на N других, есть пара электронщиков, админов и целая армия разгильдяев. В итоге, на весь курс находится лишь десяток человек, у которых можно хоть чему-то научиться.
Хочу рассказать немного о моих изысканиях по codeplex and googlecode по части матбилиотек и библиотек структур данных. С одной стороны - я был в восторге, работая с некоторыми из них, с другой стороны - руки опускаются, когда видишь, что последний коммит был аж в 2007-2008 году. Но обо всем по порядку. Статью я поделил на несколько частей, что бы сразу не перегружать её большим количеством информации. Вначале я расскажу о библиотеках на C# и затем сравню с тем, что нашел по части Java. 
Итак, список того, что я смотрел и куда даже пытался делал коммиты :
Часть1:
<ul>
<li><a href="http://numerical.codeplex.com/">Numerical Methods on C#</a></li>
<li><a href="http://silverlightnumeric.codeplex.com/">Numerical Methods on Silverlight</a></li>
<li><a href="http://npack.codeplex.com/">Npack</a></li>
<li><a href="http://smartmathlibrary.codeplex.com/">SmartMathLibrary</a></li>
<li><a href="http://dynaprecision.codeplex.com/">DynaPrecision</a></li>
</ul>
<a href="http://habrahabr.ru/blogs/open_source/101013/">Часть2</a>:
<ul>
<li><a href="http://dotrandom.svn.sourceforge.net/viewvc/dotrandom/">DotRandom</a><br>
</li>
<li><a href="http://freemath.cvs.sourceforge.net/viewvc/freemath/FreeMath/">FreeMath</a><br>
</li>
<li><a href="http://yacascs.svn.sourceforge.net/viewvc/yacascs/">Yacascs</a> <br>
</li><li>И многое другое</li>
</ul>
<a href="http://habrahabr.ru/blogs/algorithm/101820/">Часть 3 (не opensource)</a>
<ul>
	<li><a href="http://www.dotnumerics.com/">DotNumerics</a> </li>
<li><a href="http://www.centerspace.net/"> NMath .NET</a> </li>
<li><a href="http://www.ffconsultancy.com/products/fsharp_for_numerics/index.html">F# for Numerics</a> </li>
<li><a href="http://www.mathworks.com/products/netbuilder/">MATLAB Builder NE</a></li>
<li><a href="http://www.extremeoptimization.com/">Extreme Optimization Numerical Libraries for .NET</a></li>
<li><a href="http://www.vni.com/products/imsl/cSharp/">IMSL Library</a></li>
</ul>
<habracut/>
Перед началом рассказа хочу сразу сказать- тестирование производительности я не проводил, тк для этого нужны конкретные задачи, а не сферические кони в вакууме, которые я могу придумать, да и работенка это на пару месяцев минимум.
<b>Часть 1</b>

<h4><b>Numerical Methods on C# AND Numerical Methods on Silverlight</b></h4>
Как можно догадаться из названия, второй проект является форком (копированием кода) первого. Естественно с добавлением некоторых "рюшечек". 
<img src="http://s004.radikal.ru/i206/1007/e1/5d9aecc54d17.jpg" alt="image"/>

Поэтому, Я буду считать этот код одним проектом. 

В данной библиотеке есть базовый функционал по:
Аппроксимации, Интерполяции, Интегрированию функций. Решатели линейных систем уравнений, очень много чего по матрицам, по статистике (генераторы чисел с нормальным распределением, гамма распределением и еще с десятком типов распределения), генераторы случайных чисел.
Вот пример численного интегрирования заданной функции 
<img src="http://i062.radikal.ru/1008/bd/2e7985c304fb.jpg" alt="image"/>

Что самое интересное, в генераторах случайных чисел ВСЕ комментарии на РУССКОМ языке. Приятно видеть, что наши (Не Российские конечно, но Украинские. Но в широком смысле слова все равно все НАШИ), разработчики участвуют в таких классных проектах, но лучше бы они комментарии и на английском дублировали. Я думаю не один Я ранее встречал комментарии на японском или испанском языках, и не один Я получал "часы удовольствия" во время отладки и разбирательства кода.

На картинке пример решения системы линейных уравнений методом ГАУСА вместе с сходным кодам.
<img src="http://i074.radikal.ru/1008/67/e97e1d1da028.jpg" alt="image"/>

<img src="http://s55.radikal.ru/i147/1008/fa/02452e18f208.jpg" alt="image"/>

Проблемой этого проекта является полное отсутствие документации как вида! Ни компилированной справки, адекватных комментариев в коде тоже днем с огнем не найдешь, ну и куда же без так любимых мною комментариев вида:

/// Description Zeidel Method
/// <param name="a">Entrance array a</param>
/// <param name="b">Entrance array a</param>
/// <param name="x">Entrance array x</param>
/// <param name="e">Precision of calculations</param>
/// <param name="n">An amount of equalizations in the system</param>
public int ZeidelMethod(double[,] a, double[] b, double[] x, double e, int n)

Начиная с библиотеки версии 8.0 появляются намеки на то, что справка все таки когда-либо будет сделана, но у текущей версии (9.3) - справки как таковой все еще нет.

Лично для меня в этой библиотеке больше всего интересны генераторы случайных чисел, которые Я с радостью буду использовать. Все остальное, думаю, пригодится кому-нибудь другому. В общем: в проекте есть еще над чем работать! Я знаю, что разработчики проекта находятся на Украине и скорее всего читают хабр, так что искренне желаю им удачи и развития их детища.

<h4>DynaPrecision</h4>

Этот проект заслуживает отдельного внимания. Почему? Потому что, по сути, библиотека является воплощением всего плохого, что есть в OpenSource для меня. 
1. НЕТ ни какой документации.
2. НЕТ ни одного теста.
3. Не понятна даже идея проекта, хотя вроде автор ее указал... 
4. НЕТ примеров использования.
5. По сути библиотека представляет некоторый набор кода, которые автор писал в своих исследовательских целях (считай "just for fun" или по-русски "чисто на поржать").

Я честно попытался понять: чего же добивался автор? Я даже построил диаграмму классов по исходным кодам сборки:
<img src="http://s44.radikal.ru/i106/1008/54/7203ca36f0ed.jpg" alt="image"/>
"Она интуитивно понятна". Потратил половину дня на изучение кода библиотеки. Ничего не понял. Зато понял, что автор заигрался с типом данных вошедшим в .net 4.0 - <b>dynamic</b>. Написал автору с просьбой предоставить хоть какую-нибудь документацию. В ответ, как всегда, тишина. 

Вот такой вот OpenSource! Нате вам код, пользуйте и радуйтесь!

<h4>SmartMathLibrary</h4>
А вот эта библиотека уже очень и весьма даже серьезна. 
<b>Её нативная часть состоит из:</b>
<ul>
	<li>BLAS</li>
	<li>PolynomicPack</li>
	<li>LuaPack</li>
	<li>FFTPack</li>
	<li>OdePack</li>
	<li>LasoPAck</li>
<li>...</li>
</ul>
Существуют обертки на управляемом коде, над нативными (на C++) библиотеками. Это сделано (как Вы уже догадались) потому, что сам проект рассчитан на возможность применения высокопроизводительных математических библиотек для научных исследований. Для тех, кто совсем не в курсе, поясню на примере описания частей библиотеки:

<b>BLAS</b> - Basic Linear Algebra Subprograms - базовые подпрограммы линейной алгебры. Предоставляет возможность производить все возможные матричные операции (некоторые из которых мне совершенно не понятны или я не знаю для чего они нужны.)
<b>FFTPack</b> - Fast Fourier Transform - быстрое преобразование Фурье. Дома мы конечно редко используем эту функцию, но те кто занимается численным моделированием очень часто пользуются данным преобразованием. Аппаратный модуль делающий преобразование Фурье - это звуковая карта. Везде, где нужно разложить что-то аналоговое в некий полином - используется это преобразование.
<b>LASO</b> - пакет для вычисления некоторых собственных значение больших (разряженных) симметричных матриц. Честно говоря, Я не очень представляю зачем это нужно, но думаю те, кто занимаются суперкомпьютерными вычислениями дольше меня, понимают практическую ценность этой библиотеки.
<b>OdePack</b> - решатель систем обыкновенных дифференциальных уравнений. В общем обычный такой решатель.
И так далее…

Что характерно для данной библиотеки: кроме модулей на неуправляемом С++ здесь присутствует огромное количество кода на управляемом C#.
На управляемом коде написаны следующие части:
<ul>
	<li>DataMining</li>
	<li>Геометрия и геометрические преобразования</li>
	<li>Генераторы случайных чисел с различными распределениями</li>
	<li>Различные функции по статистике</li>
	<li>Комплексные числа и операции с ними</li>
	<li>Операции ввода вывода, чтения данных определенных форматов</li>
	<li>Численное интегрирование</li>
</ul>

и еще <i><b>СОТНИ</b></i> других. Всего в проекте 660 файлов на C# и изучить их все, лично на мой взгляд, не представляется возможным (менее чем за неделю и без фундаментальных знаний в области математики).

В этом проекте мне особенно нравится:
1. <b>Отличная документация</b> и даже UML диаграммы, хотя они и не в традиционном для VS 2010 виде, а в виде html:
<img src="http://s56.radikal.ru/i152/1008/88/2db9489aa91a.jpg" alt="image"/>

2. Обширное покрытие различных областей математики. 
3. Наличие средств ввода-вывода.
4. Довольно регулярные коммиты 

Конечно, есть мелочи, которые доставили мне неудобство, но с ними можно мириться:
1. Для сборки проекта пришлось "пошаманить". Мануала по сборке Я как то не нашел...
2. Некоторый бардак в папках проекта. Лично для меня не понятно: почему векторы и точки находятся частью в папке "геометрия", а частью просто в корне, многие интерфейсы также не понятно к чему относятся - они тоже лежат в корневом каталоге.
3. И ГЛАВНЫЙ МИНУС: ПОЛНОЕ ОТСУТСТВИЕ ТЕСТОВ И ПРИМЕРОВ.
Подводя итог: перечисленные мелочи не остановят человека, которому нужно использовать эту библиотеку. И от себя лично: Она мне наверное больше всех понравилась…

<h4>Npack</h4>
Эта библиотека создана для операций над матрицами и векторами из управляемого кода, с возможностью в будущем использовать графические карты (GPGPU).
Она является портом библиотеки <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a>, и, как не сложно догадаться, с Java.
Если учесть, что библиотека предназначена для матричных операций, то практически все, что она умеет - это работать с матрицами. Библиотека довольно полно покрывает матричные операции, но, лишь ФОРМАЛЬНО. Внутри методов запросто можно найти подобный код:

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li> </li><li>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">public</font> IMatrix&#60;T&#62; Multiply(IMatrix&#60;T&#62; b)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;}</li><li>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">public</font> IMatrix&#60;T&#62; One</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">get</font> { <font color="#0000ff">return</font> Identity(Format, RowCount); }</li><li>&nbsp;&nbsp;&nbsp;&nbsp;}</li><li>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">public</font> <font color="#0000ff">bool</font> GreaterThan(IMatrix&#60;T&#62; <font color="#0000ff">value</font>)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;}</li><li>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">public</font> <font color="#0000ff">bool</font> GreaterThanOrEqualTo(IMatrix&#60;T&#62; <font color="#0000ff">value</font>)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">throw</font> <font color="#0000ff">new</font> NotImplementedException();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;}</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>

Статус этой библиотеки также представляет для меня тайну за семью комментариями. Были коммиты в репозитарий в 2009 году и даже был 1 коммит этим летом. Но на главной странице гордо красуется план работ на 2007 год. 
Очень интересной особенностью этого проекта является хорошее покрытие его тестами, которые написаны не на базе традиционных MSTEST или NUnit, а с применением несколько нетрадиционного <a href="http://habrahabr.ru/blogs/net/79755/">XUNIT</a>.
Тесты есть, а документации - нет! В общем можно сделать вывод, что проект умер (Проект умер - да здравствует проект!). Думаю, данный код вполне можно использовать для интеграции в другие проекты. Вихрь Мерсена (генерация случайных чисел) в нем вполне нормальна, есть здесь и другие удачные решения.

<b>Ни кто не хочет взяться?</b>
<h4>Первые выводы</h4>
OpenSource бывает разный. В научном сообществе (да и во всех остальных, в принципе, тоже), не принято полагаться на веру и честное слово человека. Все подвергать сомнению, все проверять. Если кто то заявляет, что открыл какой-то эффект, то этому человеку принято НЕ верить. Поставят аналогичный эксперимент и, ЕСЛИ найденный эффект повторится - открытие будет принято. 

Поскольку наука - вещь серьёзная, то программы тщательно проверяют, отлаживают. Результаты вычислений проходят валидацию. Никто не будет ставить на алтарь своё Имя ученого\инженера, не проверив полученных данных. 
Лично Я в своих программах, в которых считается что либо - использую множество тестов. Во первых программы покрыты "юнит" тестами на 99% (Я бы не назвал их юнит тестами, потому как не все тесты соответствуют принципу тестирования части кода независимо от других тестов). Во вторых код покрыт функциональными тестами. Да, тесты выполняются долго. Полный прогон для 4х тысяч строк занимает около 10ти минут. Но это та плата, которую приходится платить за то, чтобы заранее обезопасить себя от лишнего месяца счета потраченного впустую. После выполнения расчетной программы есть даже целая группа тестов, которая валидирует заранее некорректные результаты: это позволяет не ковыряться руками в сотнях мегабайт выходных данных. Все вместе - это довольно весомая инфраструктура решения. 
Из всего вышесказанного: для меня <b>не понятны математические библиотеки</b>, которые совершенно <b>не покрыты тестами</b>.

Вторая встреченная мною проблема заключается в том, что во многих библиотеках идет многократный дубляж одних и тех же функций, например, таких как генераторы случайных чисел. В частности, Вихрь Мерсена, Я видел 3 раза, причем внутренний код - абсолютно идентичен, тому, что Я видел еще на 2ом курсе (написанном на С). Дубляж - это плохо. Это распыление сил, причем чудовищное.

И в завершении - самое обидное: проекты бросаются. Ничто так сильно не подрывает силы, как брошенный проект!

<b>Продолжение во 2ой части будет доступно в среду.</b>

В качестве ответа к некоторым комментариям.
0- пишу о C# потому, что это ближе всего сейчас мне. Кто хочет, напишите о других платформах и языках, я буду рад узнать и сравнить.
1- это лишь первая часть из 3 статей. Еще многое впереди.
2- то, что в статьей ведется речь об C# именно указано еще до хабраката, и все претензии что кому-то лень читать и кто-то не осилил много букв не уместны, раз зашли в такой пост.
3- сравнение с Java будет вообще в отдельной статьей послу трех указанных.
4- ...