Создатели .Net Framework в 4.0 версии своего детища очень хорошо потрудились в области параллельного программирования и отладки. Но сам факт наличия возможностей в языке, фреймворке, среде разработки еще ничего не значит. Необходимо применять все это добро.Но есть определенная инерция в умах разработчиков что: параллельные программы можно писать только на С/C++/fortran/ или ну на самый крайний случай на java. В связи с этим разработчики .Net 4.0 выпустили очень интересный набор примеров, расширяющих те примеры которые были доступны в  VS2010 training kit . Как пишут сами разработчики этих примеров они может самую капельку бажные.  Об этих примерах использования .Net для параллельного программирования я и расскажу далее.
<habracut/> 
Это лишь небольшой обзор, того что есть в этом наборе примеров. <br>
Сами коды можно скачать <noindex><a rel="nofollow" href="http://code.msdn.microsoft.com/ParExtSamples">тут</a></noindex> <br>
Почитать блог разработчиков <noindex><a rel="nofollow" href="http://blogs.msdn.com/pfxteam/default.aspx">тут</a></noindex> <br>
<br>
<b>Асоциальные роботы </b> <br>
Экран. Множество точек. Нажав на экран мышкой мы добавляем новую порцию точек. <br>
Алгоритм по шагово располагает точки на максимальном расстоянии друг от друга. В этом и есть смысл асоциальный. Точки пытаются максимизировать расстояние до соседних точек. <br>
<img src="http://s53.radikal.ru/i142/1004/61/ca3bfccedbcb.jpg" alt="image"/>
 <br>
Параллелизма тут конечно мало, но ускорение наблюдается при таком алгоритме. Сам алгоритм находится в MainWindow.Xaml.cs <br>
<br>
<b>BabyName</b> забавная программа, демонстрирующая работу linq и plinq.&nbsp; Алгоритм выбирает записи по указанному имени и штату (ассоциированному с этим именем) <br>
<img src="http://s56.radikal.ru/i152/1004/c7/4139db6adeee.jpg" alt="image"/> <br>
Просто и красиво. Разница между параллельной версией и не параллельной только в том, что в plinq к запросу добавлено .AsParallel. весь остальной код идентичен. <br>
Сам код фильтрации находится в файле Queries.cs <br>
<br>
<b>BlendImages </b> <br>
Маленькая программка, которая соединяет между собой 2&nbsp; изображения. <br>
Использует внутри себя сборку ParallelExtensionsExtras. вместо простой Bitmap использует FastBitmap (расположена в ParallelExtensionsExtras и является улучшенной версией Bitmap. о внутреннем содержании можно узнать заглянув во внутрь или подождать немного, пока я опишу всю эту красоту в следующей статье) <br>
Есть вариант работа в последовательном режиме и параллельном. <br>
В параллельном используется TPL в частности Parallel.For <br>
<br>
<b>LinqRayTracer и RayTracer </b> <br>
Есть довольно стандартная, но с другой стороны очень сложная графическая задача-Трассировка лучей. 
<img src="http://s49.radikal.ru/i126/1004/cf/be341a6f431c.jpg" alt="image"/> <br>

Кто хочет испугаться- Милости просим посмотреть на код. Есть кто понимает как это работает- Мое вам уважение! <br>
Существует 3 интересные версии этого примера. на функциональном языке F#. С применением PLINQ и используя обычный, всем понятный язык C# с применением TPL Parallel.For <br>
Наблюдается забавный эффект в&nbsp; PLinq версии. Сверх линейное ускорение. <br>
9 секунд на 1 ядре и 3 на 2 ядрах. Стоит разобраться, как это происходит. Не должно быть сверх линейного ускорения <br>
<br>
<b><br>
ComputePi </b> <br>
Не сложная задачка по вычислению числа Pi. Последовательно, последовательно с использованием Linq.
Параллельно с использованием Linq,&nbsp; Параллельный For с блокировкой , Параллельный Foreach с разбиением области <br>
вычисления на количество процессоров. Ничего интересного кроме того, факта что если разбить области на под области <br>
даже с блокировками при разбиении области счета на под области считает более чем в 2 раза, за счет того что блокировки <br>
как таковой не происходит. тк область разбита между потоками и ни кто не кого не ждет. <br>
<br>
<b>NQueens </b> <br>
Считается последовательно и параллельно возможное количество <br>
позиций на шахматной доске которые могут заниматься N ферзей на шахматной доске N*N , не бьющих друг друга. честно говоря я не представитель олимпиадного движения, по этому лучше обратитесь <br>
к поисковикам что бы понять что там происходит. От себя скажу только что в параллельном случаи используется PLINQ <br>
<br>
<b>Morph </b> <br>
Программка, которая накладывает одно изображение на другое. На входе 2 кадра, которые накладываются один на другой пошагово. <br>
На выходе либо набор картинок либо видео файл с пошаговым наложением. Делается это довольно не сложно: <br>
Берется одна картинка каждому пикселю ставится максимальный вес, и вторая с минимальным весом. Складывается. <br>
На следующем шаге один из весов уменьшается, а второй увеличивается. Так и создается множество картинок, <br>
в которых одна картинка превращается в другую. <br>
Основной расчет находится в классе&nbsp; ComputeMorph, и параллельная версия выполняется на основе TPL Parallel.For <br>
<br>
<b>ParallelGrep </b> <br>
Параллельная версия не безизвестной утилиты grep. использует технологию PLINQ <br>
<br>
<b>Mandelbrot </b> <br>
Стандартная задача, создание множества Мандельброта. <br>
<img src="http://i077.radikal.ru/1004/03/384a799939c5.jpg" alt="image"/><br>
Параллельная версия на C# используется Parallel.For как и C++ Parallel::For <br>
<br>
<b>Strassen </b> <br>
Для всех демонстраций параллелизма и параллельных вычислений в качестве примера используют перемножение матриц. <br>
Это идеальная с точки зрения распараллеливания задача. Самый простая реализация алгоритма перемножения матриц имеет <br>
порядок сложности O(n^3). Есть и другие алгоритмы, на пример Алгоритм Штрассена, имеющий большую константу O но порядок сложности <br>
ниже и равен O(n^2.87). Распараллеливание его куда более интересно. Кому интересно есть интересно рекомендую прочитать книгу: <br>
Корман, Риверст, ЛИзерсон, Штайн: Алгоритмы построение и анализ, а так же что-нибудь про перемножение матриц методом Штрассена. <br>
В параллельной версии реализации алгоритма Штрассена используются объект Task ,в то время как стандартная версия алгоритма перемножения матриц использует куда более простой способ а именно Parallel.For 


<br/>
<b>ShakespeareanMonkeys </b>
<br/>
<img src="http://i032.radikal.ru/1004/e5/c1c376d10d2b.jpg" alt="image"/> <br>
Очень миленкая программа... В общем программка доказывает, утверждение: Если посадить мартышку за печатную машинку, и дать ей неограниченное время, то рано или поздно по теории вероятности она напишет войну и мир. <br>
<br>
<b>GameOfLife </b> <br>
Реализация стандартной олимпиадной задачи- игра жизнь. <br>
Распараллеливание идет на Task <br>
<br>
<b>VisualizePartitioning </b> <br>
Самое интересное приложения лично для меня. Из названия понятно, что занимается оно визуализацией различных способов планирования (дробления задач на подзадачи) выполнения потоков и исполнении их на различных ядрах. В примерах продемонстрировано как можно разбивать на задачи. <br>
<br>
Я описал лишь часть примеров находящихся в этом наборе, но думаю самый интересные с моей точки зрения. Тк исходные коды открыты, то любой может их изучить... <br>
Описание планировщика будет в дальнейшей статье. <br>
Описание содержимого <img border="0" src="http://file:///C:/Users/SYCHEV~1/AppData/Local/Temp/moz-screenshot.png">ParallelExtensionsExtras тоже в следующих статьях будет. <br>
<br>
P.S. В общем&nbsp; основной вывод по этим примерам: программировать параллельные программы с помощью .Net можно и нужно. Множество примеров это доказывают. <br>

		<div class="blog-clear-float"></div>
	</div>