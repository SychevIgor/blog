И так, в предыдущей <a href="http://habrahabr.ru/blogs/net/92016/">статье </a>я немножко рассказал про набор примеров параллельного программирования на .net 4.0 В этой статье я хочу рассказать про способы балансировки нагрузки или если быть точнее- способы разбиения данных на части(Partitions) для более эффективной параллельной обработки 
<habracut/> 
В статье рассматриваются параметры 3 способов параллельной обработки 
<ul>
<li>Parallel.For</li>
<li>Parallel.Foreach</li>
<li>PLINQ</li>
</ul>
Не секрет, что не всегда возможно обрабатывая данные в несколько потоков, получить их равномерную загрузку и равное количество выполненных "задач" (возможно у "задачи" нет монопольного доступа на использования ресурсов процессора или ядра, возможно что часть "заданий" будет выполнять быстрее чем другие.) В некоторых случаях необходимо обеспечить балансировку нагрузки, даже между разными вычислителями.
Примеры на которых я объясняю можно скачать <a href="http://code.msdn.microsoft.com/ParExtSamples">тут </a>. Сами примеры не мои, а предоставлены разработчиками .NET 4.0
<br />

По этому в некоторых случаях стоит принудительно указать планировщику, о том, как он должен дробить задание на порции, для более эффективной обработки (я уверен, что&nbsp; в 90% случаях можно обойтись и без такого разделения, но в оставшихся 10% грамотное разбиение данных, может здорово сэкономить время расчета). 
<br />


Так выглядит приложение на котором я и буду рассказывать и показывать магию 
<br />

<img src="http://s005.radikal.ru/i211/1004/03/fab472f57baa.jpg" alt="image"/>
<br />

У приложения есть несколько частей: 
<br />

<b>1-Тип параллельной обработки</b>(For,Foreach,PLINQ) 
<b>
2-Способы разбиения на части (Partitioning ) </b>и <b>Способы разделения нагрузки</b> (Workload эта часть не является встроенной в framework. это уже наши личный способы балансировки, которые мы строим на основе знаний о коде и времени работы). 

<b>3-Экран для визуализации</b>, какая часть "работы" была выполнена каким потоком (я использую 2 ядра для экспериментов) 

<br />

Весь код о котором я рассказываю, находится в проекте VisualizePartitioning_CSharp файле MainForm.cs функции &nbsp;&nbsp;&nbsp; 
<br />

<b>Начнем с Parallel.For</b>

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li><font color="#0000ff">if</font> (useParallelFor)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parallel.For(0, height, <font color="#0000ff">new</font> ParallelOptions</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxDegreeOfParallelism = numProcs</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, i =&#62;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> id = threadId.Value;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoWork(selectedWorkload.Item2(height, i));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> (<font color="#0000ff">int</font> j = 0; j &#60; width; j++)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastBmp.SetColor(j, i, _colors[id % _colors.Length]);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ParallelOptions t = <font color="#0000ff">new</font> ParallelOptions();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.TaskScheduler = TaskScheduler.Current;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//TaskScheduler.</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//var p = t.TaskScheduler.Id;</font></li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//t.MaxDegreeOfParallelism = 4;</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//t.CancellationToken.ThrowIfCancellationRequested();</font></li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>

Во первых в качестве опций мы можем задать "максимальную степень параллелизма" (MaxDegreeOfParallelism = numProcs. в моем случаи равно 2. количеству ядер на машине) Этот параметр очень важен, но не всегда стоит выставлять его в максимальное число ядер на машине. Часто бывают задачи, которые более чем на определенном числе ядер не будут давать прироста производительности при добавлении. 

В качестве примера, когда большее количество потоков не дадут прироста производительности можно назвать следующий: 
Цвет в палитре RGB задается 3 компонентами; red, green, blue. Допустим мы решили сделать какой либо фильтр. Написали его последовательную реализацию. Затем решили обработать параллельно. Решили, что будем каждую компонент цвета обрабатывать отдельно в разных потоках R отдельно, G отдельно и B тоже отдельно. Тогда использования более 3 потоков не как не скажется на производительности (на самом деле может ухудшиться, а может незначительно улучшиться. Но не будем лезть в тонкости). Другие настройки входящие в ParallelOptions не относятся к теме статьи и возможно войдут в другую статью. 

<b>Parallel.Foreach</b>
В основном Parallel.Foreach похож на обычный foreach, но с указанием количества потоков в которых произвести обработку и кусочка работы, которые выполнять.

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li><font color="#0000ff">if</font> (useParallelForEach)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// Run the work with Parallel.ForEach</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parallel.ForEach(partitioner, <font color="#0000ff">new</font> ParallelOptions</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxDegreeOfParallelism = numProcs</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, i =&#62;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> id = threadId.Value;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoWork(selectedWorkload.Item2(height, i));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> (<font color="#0000ff">int</font> j = 0; j &#60; width; j++)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastBmp.SetColor(j, i, _colors[id % _colors.Length]);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>

<b>PLINQ</b>
Не могу себя назвать специалистом по  Linq, но PLINQ ведь и создан, для того что бы если используешь Linq запросы, получить ускорение практически даром, добавив AsParallel к выражению. 

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li><font color="#0000ff">else</font> <font color="#008000">// PLINQ</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// Run the work with PLINQ.&nbsp;If a special partitioning method was selected, use relevant query operators</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// to get PLINQ to use that partitioning approach.</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">var</font> source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (selectedMethod.Item1 == PartitioningStripe)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source = source.TakeWhile(elem =&#62; <font color="#0000ff">true</font>);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">else</font> <font color="#0000ff">if</font> (selectedMethod.Item1 == PartitioningHash)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source = source.Join(Enumerable.Range(0, height).AsParallel(), i =&#62; i, i =&#62; i, (i, ignore) =&#62; i);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source.ForAll(i =&#62;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font> id = threadId.Value;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoWork(selectedWorkload.Item2(height, i));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font> (<font color="#0000ff">int</font> j = 0; j &#60; width; j++)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fastBmp.SetColor(j, i, _colors[id % _colors.Length]);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>


<b>Способы дробления работы на части(Partitions)</b> 

Все способы разбиения можно найти пространстве имен using System.Collections.Concurrent.Partitioners; классе Partitioner, имеющий метод Create с различными перегрузками, для различных способов распределения 

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li><font color="#0000ff">private</font> <font color="#0000ff">void</font> InitializePartitioningMethods()</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lvPartitioningMethods.Items.Clear();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">bool</font> usingPLINQ = rbPLINQ.Checked;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">var</font> partitioningMethods = <font color="#0000ff">new</font> <font color="#2B91AF">List</font>&#60;Tuple&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;&#62;();</li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// Static partitioning using the Partitioner.Create overload requires static partitioner support,</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// which Parallel.ForEach does not provide.</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (usingPLINQ)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Static"</font>, e =&#62; Partitioner.Create(e, <font color="#0000ff">false</font>)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Load Balance"</font>, e =&#62; Partitioner.Create(e, <font color="#0000ff">true</font>)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Dynamic(1)"</font>, e =&#62; ChunkPartitioner.Create(e, 1)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Dynamic(16)"</font>, e =&#62; ChunkPartitioner.Create(e, 16)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Guided"</font>, e =&#62; ChunkPartitioner.Create(e, prev =&#62;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (prev &#60;= 0)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">return</font> e.Length &#60;= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">var</font> next = prev / 2;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">return</font> next &#60;= 0 ? prev : next;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})));</li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Grow Exponential"</font>, e =&#62; ChunkPartitioner.Create(e, prev =&#62; prev &#60;= 0 ? 1 : prev * 2)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#A31515">"Random"</font>, e =&#62; ChunkPartitioner.Create(e, prev =&#62; _localRandom.Value.Next(e.Length))));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// Special-case some PLINQ-only hashing)</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font> (usingPLINQ)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// The actual enabling of these partitioning schemes is done later, as they can't </font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PartitioningStripe, e =&#62; Partitioner.Create(e)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partitioningMethods.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>[], Partitioner&#60;<font color="#0000ff">int</font>&#62;&#62;&#62;(</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PartitioningHash, e =&#62; Partitioner.Create(e)));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>

 В этом коде показаны наверное все возможные способы разделения данных на части. Вызывается Partitioner.Create и далее в качестве параметров передается либо источник, который дробить на части и способ распределения, либо границы разделения. 
<br />

В качестве аналогии смысла дробления одной работы на подзадачи хочу привести торт.&nbsp; Мы берем большой торт, режим его на кусочки. Кто то будет совсем чуть чуть торта, кто то готов съесть весь торт и еще попросит добавки. По этому есть смысл нарезать торт на кусочки определенным образов, которые как МЫ считаем соответствует составу присутствующих за столом. Если разрезать торт на слишком большие куски, то кто то может не съесть (в терминах параллельного программирования -это означает что какой то из потоков, закончит работу позже, и этим будет задерживать работу всех остальных ). Но если нарезать на достаточно небольшие порции, то кто то сможет забрать несколько кусочков торта, а кому то хватит и одного. В этом и есть смысл разделения работы на подзадачи, что бы ее можно было выполнить частями.&nbsp; 
<br />


<b>Способы разделения частей между потоками</b> указываются в проекте VisualizePartitioning_CSharp файле MainForm.cs функции &nbsp; 
<br />

<blockquote><code><font size="2" face="Courier New" color="black"><ol><li><font color="#0000ff">private</font> <font color="#0000ff">void</font> InitializeWorkloads()</li><li>&nbsp;&nbsp;&nbsp;&nbsp;{</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lvWorkloads.Items.Clear();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">var</font> workloads = <font color="#0000ff">new</font> <font color="#2B91AF">List</font>&#60;Tuple&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>, <font color="#0000ff">int</font>&#62;&#62;&#62;();</li><li>&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// NOTE: To add a new workload, simply add a new entry below with a name and corresponding function</font></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workloads.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>, <font color="#0000ff">int</font>&#62;&#62;(<font color="#A31515">"Constant"</font>, (size, current) =&#62; 1000 * _workFactor));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workloads.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>, <font color="#0000ff">int</font>&#62;&#62;(<font color="#A31515">"Increasing Linear"</font>, (size, current) =&#62; 200 * current * _workFactor));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workloads.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>, <font color="#0000ff">int</font>&#62;&#62;(<font color="#A31515">"Decreasing Linear"</font>, (size, current) =&#62; 200 * (size - current) * _workFactor));</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workloads.Add(Tuple.Create&#60;<font color="#0000ff">string</font>, Func&#60;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>, <font color="#0000ff">int</font>&#62;&#62;(<font color="#A31515">"Random"</font>, (size, current) =&#62; _localRandom.Value.Next(100, 10000) * _workFactor));</li></font></ol><font size="1" color="gray">* This source code was highlighted with <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font size="1" color="gray">Source Code Highlighter</font></a>.</font></code></blockquote>


Повторяю!!! Workload&nbsp; не является встроенной в framework. это уже наши личный способы балансировки, которые мы строим на основе знаний о коде и времени работы. Если вернуться к торту, то это будет означать как раз следующее- в зависимости от желания, можно взять несколько кусочков торта. (С точки зрения параллельного программирования: поток который отработал быстрее возьмет на&nbsp; себе дополнительную часть работы, что бы не простаивать и ускорить общее время выполнения работы) Наша задача ведь съесть торт, а кто и сколько съел не важно. Главное что бы сделать это максимально быстро. 

Теперь по подробнее о результатах, которые мы получим проведя все возможные эксперименты: 

В частности в случаи Static или Load Balance передается массив, для разделения на части и вторым параметров указывается сделать балансировку нагрузки или не делать. 
<br />

В случаи есть установить Load Balance в true, то диспетчер будет пытаться 
<br />

сбалансировать загрузку ядер и скорее всего, мы получим загрузку на ядра примерно такую. Количество выполненной работы не равномерно, но время работы разных потоков идентично 
<br />
<img src="http://i030.radikal.ru/1004/3d/25285d58a9e6.jpg" alt="image"/>


<br />


Допустим мы разбили работу на части по 1 и по 16 частей. 
<br />

<img width="240px" height="280px" src="http://s58.radikal.ru/i162/1004/ee/783a3c83ede7.jpg" alt="image"/>

<br />
<img width="240px" height="280px" src="http://i029.radikal.ru/1004/d0/77af72d064e9.jpg" alt="image"/>



 Теперь каждый поток получил в свое распоряжение в одном случаи 1 порцию работы, а во втором случаи 16 порций работы. При этом не кто не гарантирует, что время выполнения работы при разбиении на 1 и на 16 частей одинаково. Оно скорее всего будет близким, но за счет удачного попадания в кэш, вполне может наблюдаться кратное различие во времени выполнения. 
<br />

В качестве заключения: 
Как я уже сказал выше в 90% случаях нет не какой необходимости вникать во все описанные способы разбиения данных и балансировки нагрузки. Но в оставшихся, надеюсь эта статья поможет разобраться и сделать параллельное приложение еще производительнее.