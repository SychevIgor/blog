SignalR появился достаточно давно, года 3 назад были первые версии и нужен он для создания Real-time веб приложений. Во всех блогах показывали “hello word” с чатом, в одно серверной конфигурации, но никто не рассказывал о приложениях из реального мира. 

В реальном/взрослом мире веб сервер не работает в одиночку, всегда работает пусть и маленькая, но ферма веб серверов, стоящих за балансировщиком. Следовательно, SignalR должен быть распределенным и событие, возникающее на одном из серверов, приходило и клиентам подключенным к другому. Поскольку о том, что SignalR поддерживает такую возможность не заслуженно не писалось, я хочу исправить это.

В SignalR есть такая фича - <b>backplane</b>, и представляет она из себя сервер баз данных (либо <b>Redis</b>, либо <b>MSSQL Server</b> и для Azure есть <b>ServiceBus</b>. Других официальных нет). На одном из хостов SignalR происходит событие, оно отправляется в базу, а оттуда уже рассылается всем подключенным к нему остальным хостам SignalR, которые ретранслируют это сообщения своим клиентам.

<img src="http://habrastorage.org/files/19d/2c0/273/19d2c0273ea84f6d84a37c96e8a2b99d.png" alt="image"/>
BackPlane в электронике- группа параллельных транзисторов. 
<habracut/>

В случаи использования Redis используется нативный для него <a href="http://redis.io/topics/pubsub">механизм</a> <a href="http://redis.io/commands/pubsub">Pub/Sub</a>, появившийся с версии Redis 2.8 (хотя и еще с версии 2.0 была возможность работать с каналами и публиковать в них сообщения).
<img src="http://habrastorage.org/files/b9a/130/24a/b9a13024ae364fd2a81477b4bf48ead4.png" alt="image"/>

В случаи SQL Server есть 2 варианта: с использованием Service Broker (это быстрый способ поддержки обмена сообщениями) и без его использования.
<img src="http://habrastorage.org/files/831/3bf/e97/8313bfe978ac49e3a2d535f0a4726e8d.png" alt="image"/>

<h5><b>Конфигурирование</b></h5>
Конфигурирование во всех 3 случаях одинаковое и достаточно простое. 
 
<img src="http://habrastorage.org/files/2c3/74b/914/2c374b914fd445c9a0655d446222e318.png" alt="image"/>

<b>Именно поэтому я бы рекомендовал использовать это решение, а не тратить человеко-месяцы старших разработчиков на написание собственных велосипедов с не гарантированным результатом.</b>

<h5><b>Реализация</b></h5>
Чтобы все работало, мы должны реализовать класс, который имплементирует интерфейс <a href="http://msdn.microsoft.com/en-us/library/microsoft.aspnet.signalr.messaging.IMessageBus(v=vs.100).aspx">IMessageBus</a>.

В нем всего 2 метода:
<img src="http://habrastorage.org/files/da2/238/a66/da2238a66a7544239fbf04100f60276a.png" alt="image"/>

Клиент к Redis/SQLServer реализует этот интерфейс через наследование от ScaleOutMessageBus, который в свою очередь наследуется от MessageBus, который уже имплементирует IMessageBus. Если захотим написать сами с нуля, то можно всю эту иерархию наследования пропустить. <a href="http://msdn.microsoft.com/en-us/library/microsoft.aspnet.signalr.redis.redismessagebus(v=vs.100).aspx ">RedisMassageBus</a> описание.

<h5><b>SQL Server реализация.</b></h5>
На github есть вот <a href="https://github.com/aspnet/SignalR-SqlServer">такой</a> проект, в котором есть код для backplane использующий SQL Server. 
<spoiler title="Внутреннее устройство я расскажу по нему, хотя не до конца уверен, что это именно то, что есть на nuget.">
Проект был порядка месяца назад опубликован, а пакеты уже года 2 доступны. Плюс в проекте всего 3 коммита, и 3 ветки, которые слабо объясняют, что в них находится, а главное - в ветке master/dev вообще ничего нет.
<img src="http://habrastorage.org/files/36a/740/68d/36a74068dc3b4253965c67e45c9a484c.png" alt="image"/>
</spoiler>
Операция <b>Send</b> выполнена как просто вставка в базу данных через SQLCommand.

Получение обновлений проходит через класс SQLStream (Кто знаком с концепциями реактивного программирования узнают код.), где SQLReciever подписывается на обновления в базе.
Для получения обновлений используется <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqldependency(v=vs.110).aspx"><b>SqlDependency</b></a>. Текст sql команд жестко забит в код и как только происходит изменения таблицы в бд, signalr получит уведомление об этом. 

В этом же проекте можно посмотреть, как происходит инициализация базы… Происходит оно через класс <b>SqlInstaller.cs</b>, который читает файл install.sql, через string.replace подменяет значения параметров (имя схемы и еще несколько параметров), затем выполняя скрипт через обычный ado.net sqlcommand. 

<img src="http://habrastorage.org/files/9ba/76d/75f/9ba76d75fcea478a80f16f18e0f2b403.png" alt="image"/>

<b>Одним словом- ракетными технологиями и не пахло.</b>

<h5><b>Реализация Redis</b></h5>
В случаи Redis, клиент подписывается на канал и ожидает ответа. Исходного кода nuget пакета на github я не нашел, а декомпилировать не вижу смысла и сейчас объясню почему.
Есть зависимость на nuget, и без декомпиляции можно сказать, что для работы с Redis используется <a href="http://www.nuget.org/packages/BookSleeve/">библиотека</a>. Эта библиотека устарела, и надо использовать StackExchange.Redis как и в остальных проектах команды Asp.net (EntityFramework, кэширование, сессии). По этому поводу даже <a href="https://github.com/SignalR/SignalR/issues/2961">задачка</a> у команды SignalR есть и в версии 2.2. команда SignalR обещает переписать.  <b>Если будут переписывать, то и смотреть сейчас смысла особого нет. </b><b>Текущая версия 2.1.2 от сентября 2014 года.</b>

<h5><b>Производительность</b></h5>
Я думаю ни для кого не станет открытием, что использование BackPlane снизит производительность на каждую конкретную ноду кластера (т.к. идет отправка данных на базу данных), и увеличит трафик между серверами т.к. сообщения полетят от базы данных ко всем нодами. Но это та цена, которую надо заплатить для если мы хотим получить горизонтальное масштабирование. Точный процент ни в статьях не указан, ни у меня посчитать не получилось. Все зависит от вашей конфигурации железа, топологии и т.п. 

Я провел эксперимент. В моем эксперименте я использовал свой ноуткбук с 2 инстансами приложения типа чата, на asp.net5 + Redis. В своих замерах я ничего интересного не смог показать, т.к. SignalR собирает несколько сообщений в пакет и после какой-то частоты замерить время отправки сообщения уже невозможно. Ну и сам net не обеспечивает сильно высокую точность замера времени, чтобы что-то меньше чем 50мс замерить.

<b>Сами Microsoft говорят о 2 потенциальных сценариях, когда backplane может быть не очень хорошо.</b>
<ul>
	<li>Когда очень <b>много серверов связанные через backplane</b>. Т.к. слишком много получается трафика между базой и серверами, с каждым новым сервером объем трафика растет квадратично…</li>
	<li>Для <b>приложений</b>, которым нужна <b>минимальная задержка</b> прихода сообщений backplane внесет дополнительную задержку (latency растет).</li>
</ul>

<b>В остальных случаях, BackPlane использовать можно, и он дает возможность использовать кластер веб серверов с SignalR.</b>

Ссылки
<ul>
	<li>http://www.asp.net/signalr/overview/performance/scaleout-in-signalr </li>
	<li>http://www.asp.net/signalr/overview/performance/scaleout-with-sql-server </li>
	<li>http://www.asp.net/signalr/overview/performance/scaleout-with-redis </li>
	<li>https://www.nuget.org/packages/Microsoft.AspNet.SignalR.Redis </li>
	<li>https://www.nuget.org/packages/Microsoft.AspNet.SignalR.SqlServer </li>
	<li>https://github.com/aspnet/SignalR-SqlServer </li>
</ul>
